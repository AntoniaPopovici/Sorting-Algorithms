# Sorting Algorithms Complexity Comparison

This code compares the complexity of five sorting algorithms: Counting Sort, Insertion Sort, Merge Sort, Shell Sort, and Radix Sort. The provided PowerPoint presentation contains detailed information about these algorithms.

## Description

The program evaluates the performance of the sorting algorithms by analyzing their execution time and correctness in sorting a given set of numbers. It uses the following algorithms:

- **Counting Sort**: An efficient sorting algorithm for integers with a limited range.
- **Insertion Sort**: A simple sorting algorithm that builds the final sorted array one item at a time.
- **Merge Sort**: A divide-and-conquer algorithm that divides the array into smaller arrays, sorts them, and then merges them.
- **Shell Sort**: An algorithm that uses a sequence of decreasing gaps to sort the elements efficiently.
- **Radix Sort**: A non-comparative sorting algorithm that sorts integers by their digit value.


## Usage

1. Run the provided code to perform the sorting algorithm comparisons.
2. Examine the output of the program to determine the correctness and efficiency of each sorting algorithm.
3. Consult the accompanying PowerPoint presentation for detailed insights into each sorting algorithm's complexity and performance.

## PowerPoint Presentation

The provided PowerPoint presentation offers a comprehensive overview of the sorting algorithms, including their complexities and performance evaluations. Refer to the slides for in-depth information and analysis.

## Notes

- Numbers \(N = 1000000\) and \(Max = 10000000\) were not tested for Counting Sort and Insertion Sort, as they are inefficient. Refer to slide 9 in the PowerPoint presentation for the running time of these algorithms.
- Some configurations were excluded for Counting Sort and Insertion Sort due to their inefficiency with large data sets.
